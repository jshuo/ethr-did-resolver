import { Base58 } from '@ethersproject/basex';
import { BigNumber } from '@ethersproject/bignumber';
import { ContractFactory } from '@ethersproject/contracts';
import { JsonRpcProvider } from '@ethersproject/providers';
import { getAddress } from '@ethersproject/address';
import { computeAddress } from '@ethersproject/transactions';
import { keccak256 } from '@ethersproject/keccak256';
import { arrayify, hexlify, concat, hexConcat, zeroPad, isHexString } from '@ethersproject/bytes';
import '@ethersproject/signing-key';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}

const identifierMatcher = /^(.*)?(0x[0-9a-fA-F]{40}|0x[0-9a-fA-F]{66})$/;
const nullAddress = '0x0000000000000000000000000000000000000000';
const DEFAULT_REGISTRY_ADDRESS = '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b';
const MESSAGE_PREFIX = '0x1900';
var verificationMethodTypes;

(function (verificationMethodTypes) {
  verificationMethodTypes["EcdsaSecp256k1VerificationKey2019"] = "EcdsaSecp256k1VerificationKey2019";
  verificationMethodTypes["EcdsaSecp256k1RecoveryMethod2020"] = "EcdsaSecp256k1RecoveryMethod2020";
  verificationMethodTypes["Ed25519VerificationKey2018"] = "Ed25519VerificationKey2018";
  verificationMethodTypes["RSAVerificationKey2018"] = "RSAVerificationKey2018";
  verificationMethodTypes["X25519KeyAgreementKey2019"] = "X25519KeyAgreementKey2019";
  verificationMethodTypes["EcdsaSecp256r1VerificationKey2019"] = "EcdsaSecp256r1VerificationKey2019";
})(verificationMethodTypes || (verificationMethodTypes = {}));

var eventNames;

(function (eventNames) {
  eventNames["DIDOwnerChanged"] = "DIDOwnerChanged";
  eventNames["DIDAttributeChanged"] = "DIDAttributeChanged";
  eventNames["DIDDelegateChanged"] = "DIDDelegateChanged";
})(eventNames || (eventNames = {}));

const legacyAttrTypes = {
  sigAuth: 'SignatureAuthentication2018',
  veriKey: 'VerificationKey2018',
  enc: 'KeyAgreementKey2019'
};
const legacyAlgoMap = {
  /**@deprecated */
  Secp256k1VerificationKey2018: verificationMethodTypes.EcdsaSecp256k1VerificationKey2019,

  /**@deprecated */
  Ed25519SignatureAuthentication2018: verificationMethodTypes.Ed25519VerificationKey2018,

  /**@deprecated */
  Secp256k1SignatureAuthentication2018: verificationMethodTypes.EcdsaSecp256k1VerificationKey2019,
  //keep legacy mapping
  RSAVerificationKey2018: verificationMethodTypes.RSAVerificationKey2018,
  Ed25519VerificationKey2018: verificationMethodTypes.Ed25519VerificationKey2018,
  X25519KeyAgreementKey2019: verificationMethodTypes.X25519KeyAgreementKey2019
};
function strip0x(input) {
  return input.startsWith('0x') ? input.slice(2) : input;
}
function bytes32toString(input) {
  const buff = typeof input === 'string' ? Buffer.from(input.slice(2), 'hex') : Buffer.from(input);
  return buff.toString('utf8').replace(/\0+$/, '');
}
function stringToBytes32(str) {
  const buffStr = '0x' + Buffer.from(str).slice(0, 32).toString('hex');
  return buffStr + '0'.repeat(66 - buffStr.length);
}
function interpretIdentifier(identifier) {
  let id = identifier;
  let network = undefined;

  if (id.startsWith('did:ethr')) {
    id = id.split('?')[0];
    const components = id.split(':');
    id = components[components.length - 1];

    if (components.length >= 4) {
      network = components.splice(2, components.length - 3).join(':');
    }
  }

  if (id.length > 42) {
    return {
      address: computeAddress(id),
      publicKey: id,
      network
    };
  } else {
    return {
      address: getAddress(id),
      network
    }; // checksum address
  }
}
var Errors;

(function (Errors) {
  /**
   * The resolver has failed to construct the DID document.
   * This can be caused by a network issue, a wrong registry address or malformed logs while parsing the registry history.
   * Please inspect the `DIDResolutionMetadata.message` to debug further.
   */
  Errors["notFound"] = "notFound";
  /**
   * The resolver does not know how to resolve the given DID. Most likely it is not a `did:ethr`.
   */

  Errors["invalidDid"] = "invalidDid";
  /**
   * The resolver is misconfigured or is being asked to resolve a DID anchored on an unknown network
   */

  Errors["unknownNetwork"] = "unknownNetwork";
})(Errors || (Errors = {}));

/**
 * Represents the known deployments of the ERC1056 registry contract.
 */
const deployments = [{
  chainId: 1,
  registry: '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b',
  name: 'mainnet',
  legacyNonce: true
}, {
  chainId: 3,
  registry: '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b',
  name: 'ropsten',
  legacyNonce: true
}, {
  chainId: 4,
  registry: '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b',
  name: 'rinkeby',
  legacyNonce: true
}, {
  chainId: 5,
  registry: '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b',
  name: 'goerli',
  legacyNonce: true
}, {
  chainId: 42,
  registry: '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b',
  name: 'kovan',
  legacyNonce: true
}, {
  chainId: 30,
  registry: '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b',
  name: 'rsk',
  legacyNonce: true
}, {
  chainId: 31,
  registry: '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b',
  name: 'rsk:testnet',
  legacyNonce: true
}, {
  chainId: 246,
  registry: '0xE29672f34e92b56C9169f9D485fFc8b9A136BCE4',
  name: 'ewc',
  description: 'energy web chain',
  legacyNonce: false
}, {
  chainId: 73799,
  registry: '0xC15D5A57A8Eb0e1dCBE5D88B8f9a82017e5Cc4AF',
  name: 'volta',
  description: 'energy web testnet',
  legacyNonce: false
}, {
  chainId: 246785,
  registry: '0xdCa7EF03e98e0DC2B855bE647C39ABe984fcF21B',
  name: 'artis:tau1',
  legacyNonce: true
}, {
  chainId: 246529,
  registry: '0xdCa7EF03e98e0DC2B855bE647C39ABe984fcF21B',
  name: 'artis:sigma1',
  legacyNonce: true
}, {
  chainId: 137,
  registry: '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b',
  name: 'polygon',
  legacyNonce: true
}, {
  chainId: 80001,
  registry: '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b',
  name: 'polygon:test',
  legacyNonce: true
}, {
  chainId: 1313161554,
  registry: '0x63eD58B671EeD12Bc1652845ba5b2CDfBff198e0',
  name: 'aurora',
  legacyNonce: true
}];

var _format = "hh-sol-artifact-1";
var contractName = "EthereumDIDRegistry";
var sourceName = "contracts/EthereumDIDRegistry.sol";
var abi = [
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "identity",
				type: "address"
			},
			{
				indexed: false,
				internalType: "bytes32",
				name: "name",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "bytes",
				name: "value",
				type: "bytes"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "validTo",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "previousChange",
				type: "uint256"
			}
		],
		name: "DIDAttributeChanged",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "identity",
				type: "address"
			},
			{
				indexed: false,
				internalType: "bytes32",
				name: "delegateType",
				type: "bytes32"
			},
			{
				indexed: false,
				internalType: "address",
				name: "delegate",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "validTo",
				type: "uint256"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "previousChange",
				type: "uint256"
			}
		],
		name: "DIDDelegateChanged",
		type: "event"
	},
	{
		anonymous: false,
		inputs: [
			{
				indexed: true,
				internalType: "address",
				name: "identity",
				type: "address"
			},
			{
				indexed: false,
				internalType: "address",
				name: "owner",
				type: "address"
			},
			{
				indexed: false,
				internalType: "uint256",
				name: "previousChange",
				type: "uint256"
			}
		],
		name: "DIDOwnerChanged",
		type: "event"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "identity",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "delegateType",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "delegate",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "validity",
				type: "uint256"
			}
		],
		name: "addDelegate",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "identity",
				type: "address"
			},
			{
				internalType: "uint8",
				name: "sigV",
				type: "uint8"
			},
			{
				internalType: "bytes32",
				name: "sigR",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "sigS",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "delegateType",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "delegate",
				type: "address"
			},
			{
				internalType: "uint256",
				name: "validity",
				type: "uint256"
			}
		],
		name: "addDelegateSigned",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "identity",
				type: "address"
			},
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "changeOwner",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "identity",
				type: "address"
			},
			{
				internalType: "uint8",
				name: "sigV",
				type: "uint8"
			},
			{
				internalType: "bytes32",
				name: "sigR",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "sigS",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "newOwner",
				type: "address"
			}
		],
		name: "changeOwnerSigned",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "changed",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "delegates",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "identity",
				type: "address"
			}
		],
		name: "identityOwner",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "nonce",
		outputs: [
			{
				internalType: "uint256",
				name: "",
				type: "uint256"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		name: "owners",
		outputs: [
			{
				internalType: "address",
				name: "",
				type: "address"
			}
		],
		stateMutability: "view",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "identity",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "name",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "value",
				type: "bytes"
			}
		],
		name: "revokeAttribute",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "identity",
				type: "address"
			},
			{
				internalType: "uint8",
				name: "sigV",
				type: "uint8"
			},
			{
				internalType: "bytes32",
				name: "sigR",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "sigS",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "name",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "value",
				type: "bytes"
			}
		],
		name: "revokeAttributeSigned",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "identity",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "delegateType",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "delegate",
				type: "address"
			}
		],
		name: "revokeDelegate",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "identity",
				type: "address"
			},
			{
				internalType: "uint8",
				name: "sigV",
				type: "uint8"
			},
			{
				internalType: "bytes32",
				name: "sigR",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "sigS",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "delegateType",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "delegate",
				type: "address"
			}
		],
		name: "revokeDelegateSigned",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "identity",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "name",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "value",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "validity",
				type: "uint256"
			}
		],
		name: "setAttribute",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "identity",
				type: "address"
			},
			{
				internalType: "uint8",
				name: "sigV",
				type: "uint8"
			},
			{
				internalType: "bytes32",
				name: "sigR",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "sigS",
				type: "bytes32"
			},
			{
				internalType: "bytes32",
				name: "name",
				type: "bytes32"
			},
			{
				internalType: "bytes",
				name: "value",
				type: "bytes"
			},
			{
				internalType: "uint256",
				name: "validity",
				type: "uint256"
			}
		],
		name: "setAttributeSigned",
		outputs: [
		],
		stateMutability: "nonpayable",
		type: "function"
	},
	{
		inputs: [
			{
				internalType: "address",
				name: "identity",
				type: "address"
			},
			{
				internalType: "bytes32",
				name: "delegateType",
				type: "bytes32"
			},
			{
				internalType: "address",
				name: "delegate",
				type: "address"
			}
		],
		name: "validDelegate",
		outputs: [
			{
				internalType: "bool",
				name: "",
				type: "bool"
			}
		],
		stateMutability: "view",
		type: "function"
	}
];
var bytecode = "0x608060405234801561001057600080fd5b506113c8806100206000396000f3fe608060405234801561001057600080fd5b50600436106100ff5760003560e01c806380b29f7c11610097578063a7068d6611610066578063a7068d66146102b5578063e476af5c146102c8578063f00d4b5d146102db578063f96d0f9f146102ee57600080fd5b806380b29f7c146102695780638733d4e81461027c578063930726841461028f5780639c2c1b2b146102a257600080fd5b8063240cf1fa116100d3578063240cf1fa146101b1578063622b2a3c146101c457806370ae92d2146102365780637ad4b0a41461025657600080fd5b8062c023da14610104578063022914a7146101195780630d44625b1461015f578063123b5e981461019e575b600080fd5b610117610112366004610ea7565b61030e565b005b610142610127366004610dd2565b6000602081905290815260409020546001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b61019061016d366004610e27565b600160209081526000938452604080852082529284528284209052825290205481565b604051908152602001610156565b6101176101ac3660046110f7565b61031f565b6101176101bf366004610f5d565b6103ab565b6102266101d2366004610e27565b6001600160a01b039283166000908152600160209081526040808320815180840196909652815180870384018152958201825285519583019590952083529381528382209290941681529252902054421090565b6040519015158152602001610156565b610190610244366004610dd2565b60036020526000908152604090205481565b610117610264366004610efe565b61048d565b610117610277366004610e27565b6104a0565b61014261028a366004610dd2565b6104ac565b61011761029d366004610fb4565b6104dc565b6101176102b0366004611013565b6105c7565b6101176102c3366004610e63565b6106b5565b6101176102d636600461107d565b6106c2565b6101176102e9366004610df4565b610741565b6101906102fc366004610dd2565b60026020526000908152604090205481565b61031a83338484610750565b505050565b6000601960f81b81306003826103348d6104ac565b6001600160a01b03166001600160a01b03168152602001908152602001600020548b88888860405160200161037098979695949392919061123e565b6040516020818303038152906040528051906020012090506103a1886103998a8a8a8a87610824565b868686610923565b5050505050505050565b6000601960f81b81306003826103c08b6104ac565b6001600160a01b0316815260208082019290925260409081016000205481516001600160f81b0319968716818501529490951660218501526bffffffffffffffffffffffff19606093841b8116602286015260368501959095528a831b851660568501527f6368616e67654f776e6572000000000000000000000000000000000000000000606a8501529186901b90931660758301528051606981840301815260899092019052805191012090506104858661047f8188888887610824565b84610a07565b505050505050565b61049a8433858585610923565b50505050565b61031a83338484610b03565b6001600160a01b0380821660009081526020819052604081205490911680156104d55792915050565b5090919050565b6000601960f81b81306003826104f18c6104ac565b6001600160a01b0316815260208082019290925260409081016000205481516001600160f81b0319968716818501529490951660218501526bffffffffffffffffffffffff19606093841b8116602286015260368501959095528b831b851660568501527f7265766f6b6544656c6567617465000000000000000000000000000000000000606a850152607884018890529186901b90931660988301528051608c81840301815260ac9092019052805191012090506105be876105b78189898987610824565b8585610b03565b50505050505050565b6000601960f81b81306003826105dc8d6104ac565b6001600160a01b0316815260208082019290925260409081016000205490516001600160f81b031995861692810192909252929093166021840152606090811b6bffffffffffffffffffffffff19908116602285015260368401929092528a811b821660568401527f61646444656c6567617465000000000000000000000000000000000000000000606a8401526075830187905285901b16609582015260a9810183905260c9016040516020818303038152906040528051906020012090506103a1886106ad8a8a8a8a87610824565b868686610bfd565b61049a8433858585610bfd565b6000601960f81b81306003826106d78c6104ac565b6001600160a01b03166001600160a01b03168152602001908152602001600020548a878760405160200161071197969594939291906111a8565b6040516020818303038152906040528051906020012090506105be8761073a8989898987610824565b8585610750565b61074c823383610a07565b5050565b838361075b826104ac565b6001600160a01b0316816001600160a01b0316146107ac5760405162461bcd60e51b81526020600482015260096024820152683130b22fb0b1ba37b960b91b60448201526064015b60405180910390fd5b6001600160a01b0386166000818152600260205260408082205490517f18ab6b2ae3d64306c00ce663125f2bd680e441a098de1635bd7ad8b0d44965e4926107f9928992899291906112db565b60405180910390a25050506001600160a01b0390921660009081526002602052604090204390555050565b6040805160008082526020820180845284905260ff8716928201929092526060810185905260808101849052819060019060a0016020604051602081039080840390855afa15801561087a573d6000803e3d6000fd5b50505060206040510351905061088f876104ac565b6001600160a01b0316816001600160a01b0316146108ef5760405162461bcd60e51b815260206004820152600d60248201527f6261645f7369676e61747572650000000000000000000000000000000000000060448201526064016107a3565b6001600160a01b03811660009081526003602052604081208054916109138361134b565b9091555090979650505050505050565b848461092e826104ac565b6001600160a01b0316816001600160a01b03161461097a5760405162461bcd60e51b81526020600482015260096024820152683130b22fb0b1ba37b960b91b60448201526064016107a3565b6001600160a01b0387167f18ab6b2ae3d64306c00ce663125f2bd680e441a098de1635bd7ad8b0d44965e486866109b18742611307565b6001600160a01b038c16600090815260026020526040908190205490516109db94939291906112db565b60405180910390a25050506001600160a01b039093166000908152600260205260409020439055505050565b8282610a12826104ac565b6001600160a01b0316816001600160a01b031614610a5e5760405162461bcd60e51b81526020600482015260096024820152683130b22fb0b1ba37b960b91b60448201526064016107a3565b6001600160a01b0385811660008181526020818152604080832080547fffffffffffffffffffffffff000000000000000000000000000000000000000016958916958617905560028252918290205482519485529084015290917f38a5a6e68f30ed1ab45860a4afb34bcb2fc00f22ca462d249b8a8d40cda6f7a3910160405180910390a2505050506001600160a01b03166000908152600260205260409020439055565b8383610b0e826104ac565b6001600160a01b0316816001600160a01b031614610b5a5760405162461bcd60e51b81526020600482015260096024820152683130b22fb0b1ba37b960b91b60448201526064016107a3565b6001600160a01b03868116600081815260016020908152604080832081518084018b90528251808203850181528184018085528151918601919091208652918452828520968a16808652968452828520429081905586865260029094529190932054928990526060810194909452608084015260a0830152907f5a5084339536bcab65f20799fcc58724588145ca054bd2be626174b27ba156f79060c0016107f9565b8484610c08826104ac565b6001600160a01b0316816001600160a01b031614610c545760405162461bcd60e51b81526020600482015260096024820152683130b22fb0b1ba37b960b91b60448201526064016107a3565b610c5e8342611307565b6001600160a01b03888116600081815260016020908152604080832081518084018d9052825180820385018152908301835280519084012084528252808320948a16835293905291909120919091557f5a5084339536bcab65f20799fcc58724588145ca054bd2be626174b27ba156f78686610cda8742611307565b6001600160a01b038c8116600090815260026020908152604091829020548251968752949092169185019190915283015260608201526080016109db565b80356001600160a01b0381168114610d2f57600080fd5b919050565b600082601f830112610d4557600080fd5b813567ffffffffffffffff80821115610d6057610d6061137c565b604051601f8301601f19908116603f01168101908282118183101715610d8857610d8861137c565b81604052838152866020858801011115610da157600080fd5b836020870160208301376000602085830101528094505050505092915050565b803560ff81168114610d2f57600080fd5b600060208284031215610de457600080fd5b610ded82610d18565b9392505050565b60008060408385031215610e0757600080fd5b610e1083610d18565b9150610e1e60208401610d18565b90509250929050565b600080600060608486031215610e3c57600080fd5b610e4584610d18565b925060208401359150610e5a60408501610d18565b90509250925092565b60008060008060808587031215610e7957600080fd5b610e8285610d18565b935060208501359250610e9760408601610d18565b9396929550929360600135925050565b600080600060608486031215610ebc57600080fd5b610ec584610d18565b925060208401359150604084013567ffffffffffffffff811115610ee857600080fd5b610ef486828701610d34565b9150509250925092565b60008060008060808587031215610f1457600080fd5b610f1d85610d18565b935060208501359250604085013567ffffffffffffffff811115610f4057600080fd5b610f4c87828801610d34565b949793965093946060013593505050565b600080600080600060a08688031215610f7557600080fd5b610f7e86610d18565b9450610f8c60208701610dc1565b93506040860135925060608601359150610fa860808701610d18565b90509295509295909350565b60008060008060008060c08789031215610fcd57600080fd5b610fd687610d18565b9550610fe460208801610dc1565b945060408701359350606087013592506080870135915061100760a08801610d18565b90509295509295509295565b600080600080600080600060e0888a03121561102e57600080fd5b61103788610d18565b965061104560208901610dc1565b955060408801359450606088013593506080880135925061106860a08901610d18565b915060c0880135905092959891949750929550565b60008060008060008060c0878903121561109657600080fd5b61109f87610d18565b95506110ad60208801610dc1565b945060408701359350606087013592506080870135915060a087013567ffffffffffffffff8111156110de57600080fd5b6110ea89828a01610d34565b9150509295509295509295565b600080600080600080600060e0888a03121561111257600080fd5b61111b88610d18565b965061112960208901610dc1565b955060408801359450606088013593506080880135925060a088013567ffffffffffffffff81111561115a57600080fd5b6111668a828b01610d34565b92505060c0880135905092959891949750929550565b6000815180845261119481602086016020860161131f565b601f01601f19169290920160200192915050565b60006001600160f81b0319808a1683528089166001840152506bffffffffffffffffffffffff19808860601b166002840152866016840152808660601b166036840152507f7265766f6b654174747269627574650000000000000000000000000000000000604a830152836059830152825161122b81607985016020870161131f565b9190910160790198975050505050505050565b60006001600160f81b0319808b168352808a166001840152506bffffffffffffffffffffffff19808960601b166002840152876016840152808760601b166036840152507f7365744174747269627574650000000000000000000000000000000000000000604a83015284605683015283516112c181607685016020880161131f565b607692019182019290925260960198975050505050505050565b8481526080602082015260006112f4608083018661117c565b6040830194909452506060015292915050565b6000821982111561131a5761131a611366565b500190565b60005b8381101561133a578181015183820152602001611322565b8381111561049a5750506000910152565b600060001982141561135f5761135f611366565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fdfea2646970667358221220216ddc889c83668a16b40556d3dc23f6e1a9fa3333587b228a11c3a0d1fad80b64736f6c63430008060033";
var deployedBytecode = "0x608060405234801561001057600080fd5b50600436106100ff5760003560e01c806380b29f7c11610097578063a7068d6611610066578063a7068d66146102b5578063e476af5c146102c8578063f00d4b5d146102db578063f96d0f9f146102ee57600080fd5b806380b29f7c146102695780638733d4e81461027c578063930726841461028f5780639c2c1b2b146102a257600080fd5b8063240cf1fa116100d3578063240cf1fa146101b1578063622b2a3c146101c457806370ae92d2146102365780637ad4b0a41461025657600080fd5b8062c023da14610104578063022914a7146101195780630d44625b1461015f578063123b5e981461019e575b600080fd5b610117610112366004610ea7565b61030e565b005b610142610127366004610dd2565b6000602081905290815260409020546001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b61019061016d366004610e27565b600160209081526000938452604080852082529284528284209052825290205481565b604051908152602001610156565b6101176101ac3660046110f7565b61031f565b6101176101bf366004610f5d565b6103ab565b6102266101d2366004610e27565b6001600160a01b039283166000908152600160209081526040808320815180840196909652815180870384018152958201825285519583019590952083529381528382209290941681529252902054421090565b6040519015158152602001610156565b610190610244366004610dd2565b60036020526000908152604090205481565b610117610264366004610efe565b61048d565b610117610277366004610e27565b6104a0565b61014261028a366004610dd2565b6104ac565b61011761029d366004610fb4565b6104dc565b6101176102b0366004611013565b6105c7565b6101176102c3366004610e63565b6106b5565b6101176102d636600461107d565b6106c2565b6101176102e9366004610df4565b610741565b6101906102fc366004610dd2565b60026020526000908152604090205481565b61031a83338484610750565b505050565b6000601960f81b81306003826103348d6104ac565b6001600160a01b03166001600160a01b03168152602001908152602001600020548b88888860405160200161037098979695949392919061123e565b6040516020818303038152906040528051906020012090506103a1886103998a8a8a8a87610824565b868686610923565b5050505050505050565b6000601960f81b81306003826103c08b6104ac565b6001600160a01b0316815260208082019290925260409081016000205481516001600160f81b0319968716818501529490951660218501526bffffffffffffffffffffffff19606093841b8116602286015260368501959095528a831b851660568501527f6368616e67654f776e6572000000000000000000000000000000000000000000606a8501529186901b90931660758301528051606981840301815260899092019052805191012090506104858661047f8188888887610824565b84610a07565b505050505050565b61049a8433858585610923565b50505050565b61031a83338484610b03565b6001600160a01b0380821660009081526020819052604081205490911680156104d55792915050565b5090919050565b6000601960f81b81306003826104f18c6104ac565b6001600160a01b0316815260208082019290925260409081016000205481516001600160f81b0319968716818501529490951660218501526bffffffffffffffffffffffff19606093841b8116602286015260368501959095528b831b851660568501527f7265766f6b6544656c6567617465000000000000000000000000000000000000606a850152607884018890529186901b90931660988301528051608c81840301815260ac9092019052805191012090506105be876105b78189898987610824565b8585610b03565b50505050505050565b6000601960f81b81306003826105dc8d6104ac565b6001600160a01b0316815260208082019290925260409081016000205490516001600160f81b031995861692810192909252929093166021840152606090811b6bffffffffffffffffffffffff19908116602285015260368401929092528a811b821660568401527f61646444656c6567617465000000000000000000000000000000000000000000606a8401526075830187905285901b16609582015260a9810183905260c9016040516020818303038152906040528051906020012090506103a1886106ad8a8a8a8a87610824565b868686610bfd565b61049a8433858585610bfd565b6000601960f81b81306003826106d78c6104ac565b6001600160a01b03166001600160a01b03168152602001908152602001600020548a878760405160200161071197969594939291906111a8565b6040516020818303038152906040528051906020012090506105be8761073a8989898987610824565b8585610750565b61074c823383610a07565b5050565b838361075b826104ac565b6001600160a01b0316816001600160a01b0316146107ac5760405162461bcd60e51b81526020600482015260096024820152683130b22fb0b1ba37b960b91b60448201526064015b60405180910390fd5b6001600160a01b0386166000818152600260205260408082205490517f18ab6b2ae3d64306c00ce663125f2bd680e441a098de1635bd7ad8b0d44965e4926107f9928992899291906112db565b60405180910390a25050506001600160a01b0390921660009081526002602052604090204390555050565b6040805160008082526020820180845284905260ff8716928201929092526060810185905260808101849052819060019060a0016020604051602081039080840390855afa15801561087a573d6000803e3d6000fd5b50505060206040510351905061088f876104ac565b6001600160a01b0316816001600160a01b0316146108ef5760405162461bcd60e51b815260206004820152600d60248201527f6261645f7369676e61747572650000000000000000000000000000000000000060448201526064016107a3565b6001600160a01b03811660009081526003602052604081208054916109138361134b565b9091555090979650505050505050565b848461092e826104ac565b6001600160a01b0316816001600160a01b03161461097a5760405162461bcd60e51b81526020600482015260096024820152683130b22fb0b1ba37b960b91b60448201526064016107a3565b6001600160a01b0387167f18ab6b2ae3d64306c00ce663125f2bd680e441a098de1635bd7ad8b0d44965e486866109b18742611307565b6001600160a01b038c16600090815260026020526040908190205490516109db94939291906112db565b60405180910390a25050506001600160a01b039093166000908152600260205260409020439055505050565b8282610a12826104ac565b6001600160a01b0316816001600160a01b031614610a5e5760405162461bcd60e51b81526020600482015260096024820152683130b22fb0b1ba37b960b91b60448201526064016107a3565b6001600160a01b0385811660008181526020818152604080832080547fffffffffffffffffffffffff000000000000000000000000000000000000000016958916958617905560028252918290205482519485529084015290917f38a5a6e68f30ed1ab45860a4afb34bcb2fc00f22ca462d249b8a8d40cda6f7a3910160405180910390a2505050506001600160a01b03166000908152600260205260409020439055565b8383610b0e826104ac565b6001600160a01b0316816001600160a01b031614610b5a5760405162461bcd60e51b81526020600482015260096024820152683130b22fb0b1ba37b960b91b60448201526064016107a3565b6001600160a01b03868116600081815260016020908152604080832081518084018b90528251808203850181528184018085528151918601919091208652918452828520968a16808652968452828520429081905586865260029094529190932054928990526060810194909452608084015260a0830152907f5a5084339536bcab65f20799fcc58724588145ca054bd2be626174b27ba156f79060c0016107f9565b8484610c08826104ac565b6001600160a01b0316816001600160a01b031614610c545760405162461bcd60e51b81526020600482015260096024820152683130b22fb0b1ba37b960b91b60448201526064016107a3565b610c5e8342611307565b6001600160a01b03888116600081815260016020908152604080832081518084018d9052825180820385018152908301835280519084012084528252808320948a16835293905291909120919091557f5a5084339536bcab65f20799fcc58724588145ca054bd2be626174b27ba156f78686610cda8742611307565b6001600160a01b038c8116600090815260026020908152604091829020548251968752949092169185019190915283015260608201526080016109db565b80356001600160a01b0381168114610d2f57600080fd5b919050565b600082601f830112610d4557600080fd5b813567ffffffffffffffff80821115610d6057610d6061137c565b604051601f8301601f19908116603f01168101908282118183101715610d8857610d8861137c565b81604052838152866020858801011115610da157600080fd5b836020870160208301376000602085830101528094505050505092915050565b803560ff81168114610d2f57600080fd5b600060208284031215610de457600080fd5b610ded82610d18565b9392505050565b60008060408385031215610e0757600080fd5b610e1083610d18565b9150610e1e60208401610d18565b90509250929050565b600080600060608486031215610e3c57600080fd5b610e4584610d18565b925060208401359150610e5a60408501610d18565b90509250925092565b60008060008060808587031215610e7957600080fd5b610e8285610d18565b935060208501359250610e9760408601610d18565b9396929550929360600135925050565b600080600060608486031215610ebc57600080fd5b610ec584610d18565b925060208401359150604084013567ffffffffffffffff811115610ee857600080fd5b610ef486828701610d34565b9150509250925092565b60008060008060808587031215610f1457600080fd5b610f1d85610d18565b935060208501359250604085013567ffffffffffffffff811115610f4057600080fd5b610f4c87828801610d34565b949793965093946060013593505050565b600080600080600060a08688031215610f7557600080fd5b610f7e86610d18565b9450610f8c60208701610dc1565b93506040860135925060608601359150610fa860808701610d18565b90509295509295909350565b60008060008060008060c08789031215610fcd57600080fd5b610fd687610d18565b9550610fe460208801610dc1565b945060408701359350606087013592506080870135915061100760a08801610d18565b90509295509295509295565b600080600080600080600060e0888a03121561102e57600080fd5b61103788610d18565b965061104560208901610dc1565b955060408801359450606088013593506080880135925061106860a08901610d18565b915060c0880135905092959891949750929550565b60008060008060008060c0878903121561109657600080fd5b61109f87610d18565b95506110ad60208801610dc1565b945060408701359350606087013592506080870135915060a087013567ffffffffffffffff8111156110de57600080fd5b6110ea89828a01610d34565b9150509295509295509295565b600080600080600080600060e0888a03121561111257600080fd5b61111b88610d18565b965061112960208901610dc1565b955060408801359450606088013593506080880135925060a088013567ffffffffffffffff81111561115a57600080fd5b6111668a828b01610d34565b92505060c0880135905092959891949750929550565b6000815180845261119481602086016020860161131f565b601f01601f19169290920160200192915050565b60006001600160f81b0319808a1683528089166001840152506bffffffffffffffffffffffff19808860601b166002840152866016840152808660601b166036840152507f7265766f6b654174747269627574650000000000000000000000000000000000604a830152836059830152825161122b81607985016020870161131f565b9190910160790198975050505050505050565b60006001600160f81b0319808b168352808a166001840152506bffffffffffffffffffffffff19808960601b166002840152876016840152808760601b166036840152507f7365744174747269627574650000000000000000000000000000000000000000604a83015284605683015283516112c181607685016020880161131f565b607692019182019290925260960198975050505050505050565b8481526080602082015260006112f4608083018661117c565b6040830194909452506060015292915050565b6000821982111561131a5761131a611366565b500190565b60005b8381101561133a578181015183820152602001611322565b8381111561049a5750506000910152565b600060001982141561135f5761135f611366565b5060010190565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fdfea2646970667358221220216ddc889c83668a16b40556d3dc23f6e1a9fa3333587b228a11c3a0d1fad80b64736f6c63430008060033";
var linkReferences = {
};
var deployedLinkReferences = {
};
var EthereumDIDRegistry = {
	_format: _format,
	contractName: contractName,
	sourceName: sourceName,
	abi: abi,
	bytecode: bytecode,
	deployedBytecode: deployedBytecode,
	linkReferences: linkReferences,
	deployedLinkReferences: deployedLinkReferences
};

const infuraNames = {
  polygon: 'matic',
  'polygon:test': 'maticmum',
  aurora: 'aurora-mainnet'
};
const knownInfuraNames = ['mainnet', 'ropsten', 'rinkeby', 'goerli', 'kovan', 'aurora'];

function configureNetworksWithInfura(projectId) {
  if (!projectId) {
    return {};
  }

  const networks = knownInfuraNames.map(n => {
    const existingDeployment = deployments.find(d => d.name === n);

    if (existingDeployment && existingDeployment.name) {
      const infuraName = infuraNames[existingDeployment.name] || existingDeployment.name;
      const rpcUrl = `https://${infuraName}.infura.io/v3/${projectId}`;
      return _extends({}, existingDeployment, {
        rpcUrl
      });
    }
  }).filter(conf => !!conf);
  return configureNetworks({
    networks
  });
}

function getContractForNetwork(conf) {
  var _conf$web;

  let provider = conf.provider || ((_conf$web = conf.web3) == null ? void 0 : _conf$web.currentProvider);

  if (!provider) {
    if (conf.rpcUrl) {
      var _deployments$find;

      const chainIdRaw = conf.chainId ? conf.chainId : (_deployments$find = deployments.find(d => d.name === conf.name)) == null ? void 0 : _deployments$find.chainId;
      const chainId = chainIdRaw ? BigNumber.from(chainIdRaw).toNumber() : chainIdRaw;
      provider = new JsonRpcProvider(conf.rpcUrl, chainId || 'any');
    } else {
      throw new Error(`invalid_config: No web3 provider could be determined for network ${conf.name || conf.chainId}`);
    }
  }

  const contract = ContractFactory.fromSolidity(EthereumDIDRegistry).attach(conf.registry || DEFAULT_REGISTRY_ADDRESS).connect(provider);
  return contract;
}

function configureNetwork(net) {
  var _deployments$find2;

  const networks = {};
  const chainId = net.chainId || ((_deployments$find2 = deployments.find(d => net.name && (d.name === net.name || d.description === net.name))) == null ? void 0 : _deployments$find2.chainId);

  if (chainId) {
    if (net.name) {
      networks[net.name] = getContractForNetwork(net);
    }

    const id = typeof chainId === 'number' ? `0x${chainId.toString(16)}` : chainId;
    networks[id] = getContractForNetwork(net);
  } else if (net.provider || net.web3 || net.rpcUrl) {
    networks[net.name || ''] = getContractForNetwork(net);
  }

  return networks;
}

function configureNetworks(conf) {
  var _conf$networks;

  return _extends({}, configureNetwork(conf), (_conf$networks = conf.networks) == null ? void 0 : _conf$networks.reduce((networks, net) => {
    return _extends({}, networks, configureNetwork(net));
  }, {}));
}
/**
 * Generates a configuration that maps ethereum network names and chainIDs to the respective ERC1056 contracts deployed
 * on them.
 * @returns a record of ERC1056 `Contract` instances
 * @param conf - configuration options for the resolver. An array of network details.
 * Each network entry should contain at least one of `name` or `chainId` AND one of `provider`, `web3`, or `rpcUrl`
 * For convenience, you can also specify an `infuraProjectId` which will create a mapping for all the networks
 *   supported by https://infura.io.
 * @example ```js
 * [
 *   { name: 'development', registry: '0x9af37603e98e0dc2b855be647c39abe984fc2445', rpcUrl: 'http://127.0.0.1:8545/' },
 *   { name: 'goerli', chainId: 5, provider: new InfuraProvider('goerli') },
 *   { name: 'rinkeby', provider: new AlchemyProvider('rinkeby') },
 *   { name: 'rsk:testnet', chainId: '0x1f', rpcUrl: 'https://public-node.testnet.rsk.co' },
 * ]
 * ```
 */


function configureResolverWithNetworks(conf = {}) {
  const networks = _extends({}, configureNetworksWithInfura(conf.infuraProjectId), configureNetworks(conf));

  if (Object.keys(networks).length === 0) {
    throw new Error('invalid_config: Please make sure to have at least one network');
  }

  return networks;
}

const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

const version$1 = "logger/5.6.0";

let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];
let _globalLogger = null;
function _checkNormalize() {
    try {
        const missing = [];
        // Make sure all forms of normalization are supported
        ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
            try {
                if ("test".normalize(form) !== "test") {
                    throw new Error("bad normalize");
                }
                ;
            }
            catch (error) {
                missing.push(form);
            }
        });
        if (missing.length) {
            throw new Error("missing " + missing.join(", "));
        }
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
            throw new Error("broken implementation");
        }
    }
    catch (error) {
        return error.message;
    }
    return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode || (ErrorCode = {}));
const HEX = "0123456789abcdef";
class Logger {
    constructor(version) {
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
            this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
            return;
        }
        console.log.apply(console, args);
    }
    debug(...args) {
        this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
        this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
        this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
        // Errors are being censored
        if (_censorErrors) {
            return this.makeError("censored error", code, {});
        }
        if (!code) {
            code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
            params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
            const value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    let hex = "";
                    for (let i = 0; i < value.length; i++) {
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                }
                else {
                    messageDetails.push(key + "=" + JSON.stringify(value));
                }
            }
            catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        let url = "";
        switch (code) {
            case ErrorCode.NUMERIC_FAULT: {
                url = "NUMERIC_FAULT";
                const fault = message;
                switch (fault) {
                    case "overflow":
                    case "underflow":
                    case "division-by-zero":
                        url += "-" + fault;
                        break;
                    case "negative-power":
                    case "negative-width":
                        url += "-unsupported";
                        break;
                    case "unbound-bitwise-result":
                        url += "-unbound-result";
                        break;
                }
                break;
            }
            case ErrorCode.CALL_EXCEPTION:
            case ErrorCode.INSUFFICIENT_FUNDS:
            case ErrorCode.MISSING_NEW:
            case ErrorCode.NONCE_EXPIRED:
            case ErrorCode.REPLACEMENT_UNDERPRICED:
            case ErrorCode.TRANSACTION_REPLACED:
            case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
                url = code;
                break;
        }
        if (url) {
            message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
        }
        if (messageDetails.length) {
            message += " (" + messageDetails.join(", ") + ")";
        }
        // @TODO: Any??
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function (key) {
            error[key] = params[key];
        });
        return error;
    }
    throwError(message, code, params) {
        throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    }
    assert(condition, message, code, params) {
        if (!!condition) {
            return;
        }
        this.throwError(message, code, params);
    }
    assertArgument(condition, message, name, value) {
        if (!!condition) {
            return;
        }
        this.throwArgumentError(message, name, value);
    }
    checkNormalize(message) {
        if (_normalizeError) {
            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize", form: _normalizeError
            });
        }
    }
    checkSafeUint53(value, message) {
        if (typeof (value) !== "number") {
            return;
        }
        if (message == null) {
            message = "value not safe";
        }
        if (value < 0 || value >= 0x1fffffffffffff) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "out-of-safe-range",
                value: value
            });
        }
        if (value % 1) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "non-integer",
                value: value
            });
        }
    }
    checkArgumentCount(count, expectedCount, message) {
        if (message) {
            message = ": " + message;
        }
        else {
            message = "";
        }
        if (count < expectedCount) {
            this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
        if (count > expectedCount) {
            this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
    }
    checkNew(target, kind) {
        if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    checkAbstract(target, kind) {
        if (target === kind) {
            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        }
        else if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    static globalLogger() {
        if (!_globalLogger) {
            _globalLogger = new Logger(version$1);
        }
        return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
            this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        if (_permanentCensorErrors) {
            if (!censorship) {
                return;
            }
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    }
    static from(version) {
        return new Logger(version);
    }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

const version = "strings/5.6.1";

const logger = new Logger(version);
///////////////////////////////
var UnicodeNormalizationForm;
(function (UnicodeNormalizationForm) {
    UnicodeNormalizationForm["current"] = "";
    UnicodeNormalizationForm["NFC"] = "NFC";
    UnicodeNormalizationForm["NFD"] = "NFD";
    UnicodeNormalizationForm["NFKC"] = "NFKC";
    UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
var Utf8ErrorReason;
(function (Utf8ErrorReason) {
    // A continuation byte was present where there was nothing to continue
    // - offset = the index the codepoint began in
    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
    // - offset = the index the codepoint began in
    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
    // The string is too short to process the expected codepoint
    // - offset = the index the codepoint began in
    Utf8ErrorReason["OVERRUN"] = "string overrun";
    // A missing continuation byte was expected but not found
    // - offset = the index the continuation byte was expected at
    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
    // The computed code point is outside the range for UTF-8
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; outside the UTF-8 range
    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
    // UTF-8 strings may not contain UTF-16 surrogate pairs
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
    // The string is an overlong representation
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; already bounds checked
    Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        let i = 0;
        for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === Utf8ErrorReason.OVERRUN) {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes);
}
// Common error handing strategies
Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
        logger.checkNormalize();
        str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
                throw new Error("invalid utf-8 string");
            }
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return arrayify(result);
}

function formatBytes32String(text) {
    // Get the bytes
    const bytes = toUtf8Bytes(text);
    // Check we have room for null-termination
    if (bytes.length > 31) {
        throw new Error("bytes32 string must be less than 32 bytes");
    }
    // Zero-pad (implicitly null-terminates)
    return hexlify(concat([bytes, HashZero]).slice(0, 32));
}

/**
 * A class that can be used to interact with the ERC1056 contract on behalf of a local controller key-pair
 */

class EthrDidController {
  /**
   * Creates an EthrDidController instance.
   *
   * @param identifier - required - a `did:ethr` string or a publicKeyHex or an ethereum address
   * @param signer - optional - a Signer that represents the current controller key (owner) of the identifier. If a
   *   'signer' is not provided, then a 'contract' with an attached signer can be used.
   * @param contract - optional - a Contract instance representing a ERC1056 contract. At least one of `contract`,
   *   `provider`, or `rpcUrl` is required
   * @param chainNameOrId - optional - the network name or chainID, defaults to 'mainnet'
   * @param provider - optional - a web3 Provider. At least one of `contract`, `provider`, or `rpcUrl` is required
   * @param rpcUrl - optional - a JSON-RPC URL that can be used to connect to an ethereum network. At least one of
   *   `contract`, `provider`, or `rpcUrl` is required
   * @param registry - optional - The ERC1056 registry address. Defaults to
   *   '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b'. Only used with 'provider' or 'rpcUrl'
   * @param legacyNonce - optional - If the legacy nonce tracking method should be accounted for. If lesser version of
   *   did-ethr-registry contract v1.0.0 is used then this should be true.
   */
  constructor(identifier, contract, signer, chainNameOrId = 'mainnet', provider, rpcUrl, registry = DEFAULT_REGISTRY_ADDRESS, legacyNonce = true) {
    this.contract = void 0;
    this.signer = void 0;
    this.address = void 0;
    this.did = void 0;
    this.legacyNonce = void 0;
    this.legacyNonce = legacyNonce; // initialize identifier

    const {
      address,
      publicKey,
      network
    } = interpretIdentifier(identifier);
    const net = network || chainNameOrId; // initialize contract connection

    if (contract) {
      this.contract = contract;
    } else if (provider || signer != null && signer.provider || rpcUrl) {
      const prov = provider || (signer == null ? void 0 : signer.provider);
      this.contract = getContractForNetwork({
        name: net,
        provider: prov,
        registry,
        rpcUrl
      });
    } else {
      throw new Error(' either a contract instance or a provider or rpcUrl is required to initialize');
    }

    this.signer = signer;
    this.address = address;
    let networkString = net ? `${net}:` : '';

    if (networkString in ['mainnet:', '0x1:']) {
      networkString = '';
    }

    this.did = publicKey ? `did:ethr:${networkString}${publicKey}` : `did:ethr:${networkString}${address}`;
  }

  async getOwner(address, blockTag) {
    const result = await this.contract.functions.identityOwner(address, {
      blockTag
    });
    return result[0];
  }

  async attachContract(controller) {
    const currentOwner = controller ? await controller : await this.getOwner(this.address, 'latest');
    const signer = this.signer ? this.signer : this.contract.provider.getSigner(currentOwner) || this.contract.signer;
    return this.contract.connect(signer);
  }

  async changeOwner(newOwner, options = {}) {
    // console.log(`changing owner for ${oldOwner} on registry at ${registryContract.address}`)
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000
    }, options);

    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const ownerChange = await contract.functions.changeOwner(this.address, newOwner, overrides);
    return await ownerChange.wait();
  }

  async createChangeOwnerHash(newOwner) {
    const paddedNonce = await this.getPaddedNonceCompatibility();
    const dataToHash = hexConcat([MESSAGE_PREFIX, this.contract.address, paddedNonce, this.address, concat([toUtf8Bytes('changeOwner'), newOwner])]);
    return keccak256(dataToHash);
  }

  async changeOwnerSigned(newOwner, metaSignature, options = {}) {
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000
    }, options);

    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const ownerChange = await contract.functions.changeOwnerSigned(this.address, metaSignature.sigV, metaSignature.sigR, metaSignature.sigS, newOwner, overrides);
    return await ownerChange.wait();
  }

  async addDelegate(delegateType, delegateAddress, exp, options = {}) {
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000
    }, options);

    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const delegateTypeBytes = stringToBytes32(delegateType);
    const addDelegateTx = await contract.functions.addDelegate(this.address, delegateTypeBytes, delegateAddress, exp, overrides);
    return await addDelegateTx.wait();
  }

  async createAddDelegateHash(delegateType, delegateAddress, exp) {
    const paddedNonce = await this.getPaddedNonceCompatibility();
    const dataToHash = hexConcat([MESSAGE_PREFIX, this.contract.address, paddedNonce, this.address, concat([toUtf8Bytes('addDelegate'), formatBytes32String(delegateType), delegateAddress, zeroPad(hexlify(exp), 32)])]);
    return keccak256(dataToHash);
  }

  async addDelegateSigned(delegateType, delegateAddress, exp, metaSignature, options = {}) {
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000
    }, options);

    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const delegateTypeBytes = stringToBytes32(delegateType);
    const addDelegateTx = await contract.functions.addDelegateSigned(this.address, metaSignature.sigV, metaSignature.sigR, metaSignature.sigS, delegateTypeBytes, delegateAddress, exp, overrides);
    return await addDelegateTx.wait();
  }

  async revokeDelegate(delegateType, delegateAddress, options = {}) {
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000
    }, options);

    delegateType = delegateType.startsWith('0x') ? delegateType : stringToBytes32(delegateType);
    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const addDelegateTx = await contract.functions.revokeDelegate(this.address, delegateType, delegateAddress, overrides);
    return await addDelegateTx.wait();
  }

  async createRevokeDelegateHash(delegateType, delegateAddress) {
    const paddedNonce = await this.getPaddedNonceCompatibility();
    const dataToHash = hexConcat([MESSAGE_PREFIX, this.contract.address, paddedNonce, this.address, concat([toUtf8Bytes('revokeDelegate'), formatBytes32String(delegateType), delegateAddress])]);
    return keccak256(dataToHash);
  }

  async revokeDelegateSigned(delegateType, delegateAddress, metaSignature, options = {}) {
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000
    }, options);

    delegateType = delegateType.startsWith('0x') ? delegateType : stringToBytes32(delegateType);
    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const addDelegateTx = await contract.functions.revokeDelegateSigned(this.address, metaSignature.sigV, metaSignature.sigR, metaSignature.sigS, delegateType, delegateAddress, overrides);
    return await addDelegateTx.wait();
  }

  async setAttribute(attrName, attrValue, exp, options = {}) {
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000,
      controller: undefined
    }, options);

    attrName = attrName.startsWith('0x') ? attrName : stringToBytes32(attrName);
    attrValue = attrValue.startsWith('0x') ? attrValue : '0x' + Buffer.from(attrValue, 'utf-8').toString('hex');
    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const setAttrTx = await contract.functions.setAttribute(this.address, attrName, attrValue, exp, overrides);
    return await setAttrTx.wait();
  }

  async createSetAttributeHash(attrName, attrValue, exp) {
    const paddedNonce = await this.getPaddedNonceCompatibility(true); // The incoming attribute value may be a hex encoded key, or an utf8 encoded string (like service endpoints)

    const encodedValue = isHexString(attrValue) ? attrValue : toUtf8Bytes(attrValue);
    const dataToHash = hexConcat([MESSAGE_PREFIX, this.contract.address, paddedNonce, this.address, concat([toUtf8Bytes('setAttribute'), formatBytes32String(attrName), encodedValue, zeroPad(hexlify(exp), 32)])]);
    return keccak256(dataToHash);
  }

  async setAttributeSigned(attrName, attrValue, exp, metaSignature, options = {}) {
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000,
      controller: undefined
    }, options);

    attrName = attrName.startsWith('0x') ? attrName : stringToBytes32(attrName);
    attrValue = attrValue.startsWith('0x') ? attrValue : '0x' + Buffer.from(attrValue, 'utf-8').toString('hex');
    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const setAttrTx = await contract.functions.setAttributeSigned(this.address, metaSignature.sigV, metaSignature.sigR, metaSignature.sigS, attrName, attrValue, exp, overrides);
    return await setAttrTx.wait();
  }

  async revokeAttribute(attrName, attrValue, options = {}) {
    // console.log(`revoking attribute ${attrName}(${attrValue}) for ${identity}`)
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000
    }, options);

    attrName = attrName.startsWith('0x') ? attrName : stringToBytes32(attrName);
    attrValue = attrValue.startsWith('0x') ? attrValue : '0x' + Buffer.from(attrValue, 'utf-8').toString('hex');
    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const revokeAttributeTX = await contract.functions.revokeAttribute(this.address, attrName, attrValue, overrides);
    return await revokeAttributeTX.wait();
  }

  async createRevokeAttributeHash(attrName, attrValue) {
    const paddedNonce = await this.getPaddedNonceCompatibility(true);
    const dataToHash = hexConcat([MESSAGE_PREFIX, this.contract.address, paddedNonce, this.address, concat([toUtf8Bytes('revokeAttribute'), formatBytes32String(attrName), toUtf8Bytes(attrValue)])]);
    return keccak256(dataToHash);
  }
  /**
   * The legacy version of the ethr-did-registry contract tracks the nonce as a property of the original owner, and not
   * as a property of the signer (current owner). That's why we need to differentiate between deployments here, or
   * otherwise our signature will be computed wrong resulting in a failed TX.
   *
   * Not only that, but the nonce is loaded differently for [set/revoke]AttributeSigned methods.
   */


  async getPaddedNonceCompatibility(attribute = false) {
    let nonceKey;

    if (this.legacyNonce && attribute) {
      nonceKey = this.address;
    } else {
      nonceKey = await this.getOwner(this.address);
    }

    return zeroPad(arrayify(await this.contract.nonce(nonceKey)), 32);
  }

  async revokeAttributeSigned(attrName, attrValue, metaSignature, options = {}) {
    // console.log(`revoking attribute ${attrName}(${attrValue}) for ${identity}`)
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000
    }, options);

    attrName = attrName.startsWith('0x') ? attrName : stringToBytes32(attrName);
    attrValue = attrValue.startsWith('0x') ? attrValue : '0x' + Buffer.from(attrValue, 'utf-8').toString('hex');
    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const revokeAttributeTX = await contract.functions.revokeAttributeSigned(this.address, metaSignature.sigV, metaSignature.sigR, metaSignature.sigS, attrName, attrValue, overrides);
    return await revokeAttributeTX.wait();
  }

}

function populateEventMetaClass(logResult, blockNumber) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const result = {};

  if (logResult.eventFragment.inputs.length !== logResult.args.length) {
    throw new TypeError('malformed event input. wrong number of arguments');
  }

  logResult.eventFragment.inputs.forEach((input, index) => {
    let val = logResult.args[index];

    if (typeof val === 'object') {
      val = BigNumber.from(val);
    }

    if (input.type === 'bytes32') {
      val = bytes32toString(val);
    }

    result[input.name] = val;
  });
  result._eventName = logResult.name;
  result.blockNumber = blockNumber;
  return result;
}

function logDecoder(contract, logs) {
  const results = logs.map(log => {
    const res = contract.interface.parseLog(log);
    const event = populateEventMetaClass(res, log.blockNumber);
    return event;
  });
  return results;
}

function getResolver(options) {
  return new EthrDidResolver(options).build();
}
class EthrDidResolver {
  constructor(options) {
    this.contracts = void 0;
    this.contracts = configureResolverWithNetworks(options);
  }
  /**
   * returns the current owner of a DID (represented by an address or public key)
   *
   * @param address
   */


  async getOwner(address, networkId, blockTag) {
    //TODO: check if address or public key
    return new EthrDidController(address, this.contracts[networkId]).getOwner(address, blockTag);
  }
  /**
   * returns the previous change
   *
   * @param address
   */


  async previousChange(address, networkId, blockTag) {
    const result = await this.contracts[networkId].functions.changed(address, {
      blockTag
    }); // console.log(`last change result: '${BigNumber.from(result['0'])}'`)

    return BigNumber.from(result['0']);
  }

  async getBlockMetadata(blockHeight, networkId) {
    const block = await this.contracts[networkId].provider.getBlock(blockHeight);
    return {
      height: block.number.toString(),
      isoDate: new Date(block.timestamp * 1000).toISOString().replace('.000', '')
    };
  }

  async changeLog(identity, networkId, blockTag = 'latest') {
    const contract = this.contracts[networkId];
    const provider = contract.provider;
    const hexChainId = networkId.startsWith('0x') ? networkId : undefined; //TODO: this can be used to check if the configuration is ok

    const chainId = hexChainId ? BigNumber.from(hexChainId).toNumber() : (await provider.getNetwork()).chainId;
    const history = [];
    const {
      address,
      publicKey
    } = interpretIdentifier(identity);
    const controllerKey = publicKey;
    let previousChange = await this.previousChange(address, networkId, blockTag);

    while (previousChange) {
      const blockNumber = previousChange;
      const logs = await provider.getLogs({
        address: contract.address,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        topics: [null, `0x000000000000000000000000${address.slice(2)}`],
        fromBlock: previousChange.toHexString(),
        toBlock: previousChange.toHexString()
      });
      const events = logDecoder(contract, logs);
      events.reverse();
      previousChange = null;

      for (const event of events) {
        history.unshift(event);

        if (event.previousChange.lt(blockNumber)) {
          previousChange = event.previousChange;
        }
      }
    }

    return {
      address,
      history,
      controllerKey,
      chainId
    };
  }

  wrapDidDocument(did, address, controllerKey, history, chainId, blockHeight, now) {
    var _didDocument$verifica;

    const baseDIDDocument = {
      '@context': ['https://www.w3.org/ns/did/v1', 'https://w3id.org/security/suites/secp256k1recovery-2020/v2'],
      id: did,
      verificationMethod: [],
      authentication: [],
      assertionMethod: []
    };
    let controller = address;
    const authentication = [`${did}#controller`];
    const keyAgreement = [];
    let versionId = 0;
    let nextVersionId = Number.POSITIVE_INFINITY;
    let deactivated = false;
    let delegateCount = 0;
    let serviceCount = 0;
    let endpoint = '';
    const auth = {};
    const keyAgreementRefs = {};
    const pks = {};
    const services = {};

    for (const event of history) {
      if (blockHeight !== -1 && event.blockNumber > blockHeight) {
        if (nextVersionId > event.blockNumber) {
          nextVersionId = event.blockNumber;
        }

        continue;
      } else {
        if (versionId < event.blockNumber) {
          versionId = event.blockNumber;
        }
      }

      const validTo = event.validTo || BigNumber.from(0);
      const eventIndex = `${event._eventName}-${event.delegateType || event.name}-${event.delegate || event.value}`;

      if (validTo && validTo.gte(now)) {
        if (event._eventName === eventNames.DIDDelegateChanged) {
          const currentEvent = event;
          delegateCount++;
          const delegateType = currentEvent.delegateType; //conversion from bytes32 is done in logParser

          switch (delegateType) {
            case 'sigAuth':
              auth[eventIndex] = `${did}#delegate-${delegateCount}`;
            // eslint-disable-line no-fallthrough

            case 'veriKey':
              pks[eventIndex] = {
                id: `${did}#delegate-${delegateCount}`,
                type: verificationMethodTypes.EcdsaSecp256r1VerificationKey2019,
                controller: did,
                blockchainAccountId: `eip155:${chainId}:${currentEvent.delegate}`
              };
              break;
          }
        } else if (event._eventName === eventNames.DIDAttributeChanged) {
          const currentEvent = event;
          const name = currentEvent.name; //conversion from bytes32 is done in logParser

          const match = name.match(/^did\/(pub|svc)\/(\w+)(\/(\w+))?(\/(\w+))?$/);

          if (match) {
            const section = match[1];
            const algorithm = match[2];
            const type = legacyAttrTypes[match[4]] || match[4];
            const encoding = match[6];

            switch (section) {
              case 'pub':
                {
                  delegateCount++;
                  const pk = {
                    id: `${did}#delegate-${delegateCount}`,
                    type: `${algorithm}${type}`,
                    controller: did
                  };
                  pk.type = legacyAlgoMap[pk.type] || algorithm;

                  switch (encoding) {
                    case null:
                    case undefined:
                    case 'hex':
                      pk.publicKeyHex = strip0x(currentEvent.value);
                      break;

                    case 'base64':
                      pk.publicKeyBase64 = Buffer.from(currentEvent.value.slice(2), 'hex').toString('base64');
                      break;

                    case 'base58':
                      pk.publicKeyBase58 = Base58.encode(Buffer.from(currentEvent.value.slice(2), 'hex'));
                      break;

                    case 'pem':
                      pk.publicKeyPem = Buffer.from(currentEvent.value.slice(2), 'hex').toString();
                      break;

                    default:
                      pk.value = strip0x(currentEvent.value);
                  }

                  pks[eventIndex] = pk;

                  if (match[4] === 'sigAuth') {
                    auth[eventIndex] = pk.id;
                  } else if (match[4] === 'enc') {
                    keyAgreementRefs[eventIndex] = pk.id;
                  }

                  break;
                }

              case 'svc':
                serviceCount++;

                try {
                  endpoint = JSON.parse(Buffer.from(currentEvent.value.slice(2), 'hex').toString());
                } catch (_unused2) {
                  endpoint = Buffer.from(currentEvent.value.slice(2), 'hex').toString();
                }

                services[eventIndex] = {
                  id: `${did}#service-${serviceCount}`,
                  type: algorithm,
                  serviceEndpoint: endpoint
                };
                break;
            }
          }
        }
      } else if (event._eventName === eventNames.DIDOwnerChanged) {
        const currentEvent = event;
        controller = currentEvent.owner;

        if (currentEvent.owner === nullAddress) {
          deactivated = true;
          break;
        }
      } else {
        if (event._eventName === eventNames.DIDDelegateChanged || event._eventName === eventNames.DIDAttributeChanged && event.name.match(/^did\/pub\//)) {
          delegateCount++;
        } else if (event._eventName === eventNames.DIDAttributeChanged && event.name.match(/^did\/svc\//)) {
          serviceCount++;
        }

        delete auth[eventIndex];
        delete pks[eventIndex];
        delete services[eventIndex];
      }
    }

    const publicKeys = [{
      id: `${did}#controller`,
      type: verificationMethodTypes.EcdsaSecp256r1VerificationKey2019,
      controller: did,
      blockchainAccountId: `eip155:${chainId}:${controller}`
    }];

    if (controllerKey && controller == address) {
      publicKeys.push({
        id: `${did}#controllerKey`,
        type: verificationMethodTypes.EcdsaSecp256k1VerificationKey2019,
        controller: did,
        publicKeyHex: strip0x(controllerKey)
      });
      authentication.push(`${did}#controllerKey`);
    }

    const didDocument = _extends({}, baseDIDDocument, {
      verificationMethod: publicKeys.concat(Object.values(pks)),
      authentication: authentication.concat(Object.values(auth))
    });

    if (Object.values(services).length > 0) {
      didDocument.service = Object.values(services);
    }

    if (Object.values(keyAgreementRefs).length > 0) {
      didDocument.keyAgreement = keyAgreement.concat(Object.values(keyAgreementRefs));
    }

    didDocument.assertionMethod = [...(((_didDocument$verifica = didDocument.verificationMethod) == null ? void 0 : _didDocument$verifica.map(pk => pk.id)) || [])];
    return deactivated ? {
      didDocument: _extends({}, baseDIDDocument, {
        '@context': 'https://www.w3.org/ns/did/v1'
      }),
      deactivated,
      versionId,
      nextVersionId
    } : {
      didDocument,
      deactivated,
      versionId,
      nextVersionId
    };
  }

  async resolve(did, parsed, // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _unused, options) {
    const fullId = parsed.id.match(identifierMatcher);

    if (!fullId) {
      return {
        didResolutionMetadata: {
          error: Errors.invalidDid,
          message: `Not a valid did:ethr: ${parsed.id}`
        },
        didDocumentMetadata: {},
        didDocument: null
      };
    }

    const id = fullId[2];
    const networkId = !fullId[1] ? 'mainnet' : fullId[1].slice(0, -1);
    let blockTag = options.blockTag || 'latest';

    if (typeof parsed.query === 'string') {
      var _qParams$get;

      const qParams = new URLSearchParams(parsed.query);
      blockTag = (_qParams$get = qParams.get('versionId')) != null ? _qParams$get : blockTag;

      try {
        blockTag = Number.parseInt(blockTag);
      } catch (e) {
        blockTag = 'latest'; // invalid versionId parameters are ignored
      }
    }

    if (!this.contracts[networkId]) {
      return {
        didResolutionMetadata: {
          error: Errors.unknownNetwork,
          message: `The DID resolver does not have a configuration for network: ${networkId}`
        },
        didDocumentMetadata: {},
        didDocument: null
      };
    }

    let now = BigNumber.from(Math.floor(new Date().getTime() / 1000));

    if (typeof blockTag === 'number') {
      const block = await this.getBlockMetadata(blockTag, networkId);
      now = BigNumber.from(Date.parse(block.isoDate) / 1000);
    }

    const {
      address,
      history,
      controllerKey,
      chainId
    } = await this.changeLog(id, networkId, 'latest');

    try {
      const {
        didDocument,
        deactivated,
        versionId,
        nextVersionId
      } = this.wrapDidDocument(did, address, controllerKey, history, chainId, blockTag, now);
      const status = deactivated ? {
        deactivated: true
      } : {};
      let versionMeta = {};
      let versionMetaNext = {};

      if (versionId !== 0) {
        const block = await this.getBlockMetadata(versionId, networkId);
        versionMeta = {
          versionId: block.height,
          updated: block.isoDate
        };
      }

      if (nextVersionId !== Number.POSITIVE_INFINITY) {
        const block = await this.getBlockMetadata(nextVersionId, networkId);
        versionMetaNext = {
          nextVersionId: block.height,
          nextUpdate: block.isoDate
        };
      }

      return {
        didDocumentMetadata: _extends({}, status, versionMeta, versionMetaNext),
        didResolutionMetadata: {
          contentType: 'application/did+ld+json'
        },
        didDocument
      }; // eslint-disable-next-line @typescript-eslint/no-explicit-any
    } catch (e) {
      return {
        didResolutionMetadata: {
          error: Errors.notFound,
          message: e.toString() // This is not in spec, nut may be helpful

        },
        didDocumentMetadata: {},
        didDocument: null
      };
    }
  }

  build() {
    return {
      ethr: this.resolve.bind(this)
    };
  }

}

export { Errors, EthereumDIDRegistry, EthrDidController, DEFAULT_REGISTRY_ADDRESS as REGISTRY, legacyAttrTypes as attrTypes, bytes32toString, legacyAlgoMap as delegateTypes, deployments, getResolver, identifierMatcher, interpretIdentifier, stringToBytes32, verificationMethodTypes };
//# sourceMappingURL=index.modern.js.map
